-- We put things inside the secure schema to hide
-- them from public view. Certain public procs/views will
-- refer to helpers and tables inside.
-- Create users table

CREATE TABLE IF NOT EXISTS secure.users (
    "id" int GENERATED BY
      DEFAULT AS IDENTITY PRIMARY KEY,
    "inserted_at" timestamp without time zone not null default now(),
    "updated_at" timestamp without time zone not null default now(),
      "email" text NOT NULL CHECK (email ~* '^.+@.+\..+$') UNIQUE,
      "pass" text NOT NULL CHECK (length(pass) < 512),
      "role" name NOT NULL CHECK (length(ROLE) < 512)
);

GRANT SELECT ON TABLE pg_authid, secure.users TO anon;


-- ----------------------------
-- Table structure for sessions
-- ----------------------------
create table "public"."session" (
  "id" text NOT NULL PRIMARY KEY default uuid_generate_v4(),
  "inserted_at" timestamp without time zone not null default now(),
  "expires" timestamp without time zone not null default CURRENT_DATE + INTERVAL '1 year',
  "user_id" int not null REFERENCES "secure"."users"
);

-- We would like the role to be a foreign key to actual database roles,
-- however PostgreSQL does not support these constraints against the pg_roles table.
-- We’ll use a trigger to manually enforce it.

CREATE OR REPLACE FUNCTION secure.check_role_exists ()
  RETURNS TRIGGER
  AS $$
BEGIN
  IF NOT EXISTS (
      SELECT
        1
      FROM
        pg_roles AS r
      WHERE
        r.rolname = new.role) THEN
      raise foreign_key_violation
      USING message = 'unknown database role: ' || new.role;
    RETURN NULL;
  END IF;
  RETURN new;
END
$$
LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS ensure_user_role_exists ON secure.users;

CREATE CONSTRAINT TRIGGER ensure_user_role_exists AFTER INSERT
OR UPDATE ON secure.users FOR EACH ROW EXECUTE PROCEDURE secure.check_role_exists ();

-- Next we’ll use the pgcrypto extension and a trigger to keep passwords safe
-- in the users table

CREATE OR REPLACE FUNCTION secure.encrypt_pass ()
  RETURNS TRIGGER
  AS $$
BEGIN
  IF tg_op = 'INSERT' OR new.pass <> old.pass THEN
    new.pass = crypt(new.pass, gen_salt('bf'));
  END IF;
RETURN new;
END
$$
LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS encrypt_pass ON secure.users;

CREATE TRIGGER encrypt_pass
  BEFORE INSERT
  OR UPDATE ON secure.users
  FOR EACH ROW
  EXECUTE PROCEDURE secure.encrypt_pass ();

-- With the table in place we can make a helper to check a password against
-- the encrypted column. It returns the database role for a user if the email
-- and password are correct.

CREATE OR REPLACE FUNCTION secure.verify_login (email text, pass text)
  RETURNS int
  LANGUAGE plpgsql
  AS $$
BEGIN
  RETURN (
    SELECT
      id
    FROM
      secure.users
    WHERE
      users.email = verify_login.email
      AND users.pass = crypt(verify_login.pass, users.pass));
END;
$$;

